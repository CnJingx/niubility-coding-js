##  二叉树的序列化与反序列化

### 题目描述

请实现两个函数，分别用来序列化和反序列化二叉树

例如给定的一棵树的结构为：

要求返回序列化为`1,2,#,#,3,4,#,#,5,#,#`

### 解题思路

**序列化思路**

1. 判断节点的值是否存在，若是不存在则需要用一个特殊符号来代替，如`#`符号；
2. 序列化实际就是将二叉树进行前序遍历

**反序列化思路**

1. 判断值为`#`的项，将其转换为`null`;
2. 输入的数组为二叉树的前序遍历，利用这一特性进行左右子树的赋值

### coding

```javascript
class Tree {
    constructor(value = 0, left = null, right = null) {
        this.value = value;
        this.left = left;
        this.right = right;
    }
}
/*
* 序列化二叉树
* param {Tree} tree 二叉树
* param {Array} arr 序列化之后的数组
* return {String} 返回序列化之后字符串
*/
function Serialize(tree, arr = []) {
    if (!tree) { // 判断该节点有没有，没有则用特殊符号 # 代替
        arr.push('#');
    } else {
        arr.push(tree.value); // 当前节点的值
        Serialize(tree.left, arr) // 分别遍历左右子树
        Serialize(tree.right, arr)
    }
    return arr.join(','); // 将返回的数组进行逗号连接（若想返回数组则不用.join(',')）
}
/*
* 反序列化二叉树，通过字符串
* param {String} str 序列化之后的字符串
*/
function DeSerializeByStr (str) {
    if (!str) return null;
    return DeserializeByArr(str.split(','))
}
/*
* 反序列化二叉树，通过数组
* param {Array} arr 序列化之后的数组
*/
function DeserializeByArr(arr) {
    let node = null; // 定义一个节点为 null
    let currentVal = arr.shift(); // 取出数组的第一项，该项为节点的值
    if (currentVal !== '#') { // 若该节点存在
        node = { value: currentVal }; // 该节点的值为 currentVal
        node.left = DeserializeByArr(arr); // 由于数组在上面执行了shift()操作，所以次数数组是改变了的
        node.right = DeserializeByArr(arr);
    }
    return node;
}
const tree = new Tree(1, new Tree(2), new Tree(3, new Tree(4), new Tree(5)))
console.log(Serialize(tree))
console.log(DeSerializeByStr('1,2,#,#,3,4,#,#,5,#,#'))
```

